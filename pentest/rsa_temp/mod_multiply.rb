require 'base64'
require 'json'

def nthroot(x,n)
  high = 1

  begin
    high *= 2
  end while high ** n <= x

  low = high / 2

  begin
    mid = (low + high) / 2

    if low < mid && mid**n < x
      low = mid
    elsif high > mid && mid**n > x
      high = mid
    else
      return mid
    end
  end while low < high

  mid + 1
end

def extended_gcd(a, b)
  last_remainder, remainder = a.abs, b.abs
  x, last_x, y, last_y = 0, 1, 1, 0

  while remainder != 0
    last_remainder, (quotient, remainder) = remainder, last_remainder.divmod(remainder)
    x, last_x = (last_x - quotient*x), x
    y, last_y = (last_y - quotient*y), y
  end

  return last_remainder, last_x * (a < 0 ? -1 : 1)
end

def invmod(e, et)
  g, x = extended_gcd(e, et)

  if g != 1
    raise 'Multiplicative inverse modulo does not exist!'
  end

  x % et
end

def chinese_remainder(mods, remainders)
  max = mods.inject(:*)
  series = remainders.zip(mods).map{ |r,m| (r * max * invmod(max/m, m) / m) }
  series.inject(:+) % max
end

lines = JSON.parse(File.read('my_encrypted.json'))

ns = lines.map { |line| line["n"].to_i(16) }
cs = lines.map { |line| line["c"].to_i(16) }

crt = chinese_remainder(ns, cs)
r = nthroot(crt, 7)
puts r.to_s(16)
puts [r.to_s(16)].pack('h*')
