# During every iteration a bunch of operations are performed for a block
# of 512 bits and the end result is composed of five 32 bit unsigned integers.
# At the last iteration these final five 32 bit unsigned integers are
# packed together and encoded as a 40 byte hexadecimal.
#
# Visually speaking:
#
# a, b, c, d, e = initial_state
# a, b, c, d, e = bunch_of_operations(block1, a, b, c, d, e)
# a, b, c, d, e = bunch_of_operations(block2, a, b, c, d, e)
# a, b, c, d, e = bunch_of_operations(blockN, a, b, c, d, e)
#
# Given that we know the original message and that we have the MAC
# generated by the original message we can attack this algorithm
# like:
#
# SHA1(key + original-message + glue-padding + new-message)
#
# 'glue-padding' is the padding that our original message received
# by the SHA1 algorithm before being hashed. So the plan of attack is:
#
# 1. Figure out the right amount of padding
# 2. Obtain the last five 32 bit unsigned integers from our original MAC.
# 3. Start a new SHA1 from the state obtained on step 2 and passing the
#    new message length.
#
# To figure out the right amount of padding we need to guess since we
# don't know the size of the key, so we can iterate from 1 to 64
# and see which key length works.
#
# To obtain the five 32 bits from step 2 we can do:
# mac = Sha1.hexdigest('my message')
# abcde = [mac].pack('H*').unpack('N5')
#
# Now we can pass our suffix to Sha1 and these five 32 bit values
# as the state and Sha1 will keep computing from there onwards.
#
# SHA1.hexdigest(suffix, abcde, original_message.size + suffix.size)
#
# And we are guaranteed to end up with a valid MAC. :)

require_relative '../helpers'
require_relative '../sha1'


PLAINTEXT = 'comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon'.bytes
SUFFIX = ';admin=true'.bytes
KEY = ['potato', 'secret', 'iranoutofideas'].shuffle.first.bytes
MAC = sha1_mac(PLAINTEXT, KEY)

def verify(forged_message, forged_mac)
  mac = sha1_mac(forged_message, KEY)

  puts "user mac: #{mac.inspect}"
  puts "our mac : #{forged_mac.inspect}"

  mac == forged_mac
end

def sha1_padding(message_len)
  mask = 0xffffffff
  bit_len = message_len << 3

  # We are dealing with bytes, but the algorithm adds a 1 bit in the
  # beginning of the padding and zeros after it. So we start adding
  # 0x80 (which is 128) or 10000000
  padding = [0x80]
  padding << 0 while ((message_len + padding.size) % 64) != 56

  # We have 64 bits for the message length, so:
  # 1. The first element of the Array is the top 32 bits
  # 2. The second element is the bottom 32 bits
  # 3. These are transformed in two 32 bit big endian unsigned integers
  #    as per the algorithm
  padding + [bit_len >> 32, bit_len & mask].pack('N2').bytes
end

def forge_mac(mac, suffix, length)
  abcde = [mac].pack('H*').unpack('N5')
  SHA1.hexdigest(suffix, abcde, length)
end

(1..20).each do |key_size|
  padding = sha1_padding(PLAINTEXT.size + key_size)
  forged_message = PLAINTEXT + padding + SUFFIX
  forged_mac = forge_mac(MAC, SUFFIX, key_size + forged_message.size)

  if verify(forged_message, forged_mac)
    puts "Key len is: #{key_size}"
    break
  end
end
